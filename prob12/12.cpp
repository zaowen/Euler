//PRoject euler: Problem 12
//Brogramer: PKing

/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

#include <iostream>
#include <cmath>
using namespace std;

double triangle( double n);
int finddiv( double n, int b[]);



int main()
{
double tri = 1;
int divisors[5000];
int found = 0;

while(finddiv(triangle(tri) , divisors) < 500)
	{	
	tri++;
	}
cout << fixed;
cout << "the answer is " << triangle(tri) << endl;

return 0;
}

//
//Function double triangle( double n )
/*
Arguments:
	double n: order of triangle number we want
Functionality:
	returns as a double the nth order triangle number recursively
	1 =		1
	1+2 = 		3
	1+2+3=		6
	1+2+3+4=	10
	1+2+3+4+5=	15
	1+2+3+4+5+6=	21
	1+2+3+4+5+6+7=	27
	etc...
Returns:
	nth order triangle number as double
Bugs:
	None

*/

double triangle(double n)
{
return (n==1? 1: triangle(n-1)+n);
};


//
//Function int finddiv( double n, int b[])
/*
Arguments:
	double n: The number we want to find the divisor of,
	int b[]: where the divisors will be stored
Functionality:
	Finds the divisors of the arg n by using implicit typecasting
	to find if n is divisible by all numbers up to one greater than the
	square root of n which shawn told me is a math law one time. Then 
	stores then in the array b[], 
Returns:
	the number of divisors
Bugs:
	1.Will break with negative values of n, probably

*/

int finddiv( double n, int b[])
{
int max = sqrt(n)+1;
int check, beaver;
beaver = 0;
for( double i = 1; i < max; i++)
	{
	check = n/i;
	if (check == n/i)
		{
		b[beaver]=i;
		if (check == i)
			{
			beaver ++;
			}
		else
			{
			b[beaver+1] = check;
			beaver += 2;
			}
		}
	}
return beaver;
}
